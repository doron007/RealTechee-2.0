/**
 * Recipient Validation System Tests
 * 
 * Tests the production-ready notification recipient validation system
 * to ensure proper environment safety and role-based filtering.
 */

import { notificationService, NotificationRecipient } from '../services/notificationService';
import { formNotificationIntegration } from '../services/formNotificationIntegration';
import { AdminService } from '../utils/adminService';

// Mock AdminService for testing
jest.mock('../utils/adminService');
const mockAdminService = AdminService as jest.Mocked<typeof AdminService>;

// Mock logger to capture logs
jest.mock('../lib/logger', () => ({
  info: jest.fn(),
  warn: jest.fn(),
  error: jest.fn(),
}));

describe('Recipient Validation System', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    
    // Reset environment variables for each test
    delete process.env.NODE_ENV;
    delete process.env.NEXT_PUBLIC_ENVIRONMENT;
    delete process.env.AMPLIFY_ENVIRONMENT;
    delete process.env.DEBUG_NOTIFICATIONS;
    delete process.env.DEBUG_EMAIL;
  });

  describe('Environment Detection', () => {
    test('should detect development environment correctly', async () => {
      process.env.NODE_ENV = 'development';
      process.env.NEXT_PUBLIC_ENVIRONMENT = 'development';
      
      const validation = await notificationService.validateEnvironment();
      
      expect(validation.environment).toBe('development');
      expect(validation.recipientValidation).toBe(true);
    });

    test('should detect production environment correctly', async () => {
      process.env.NODE_ENV = 'production';
      process.env.NEXT_PUBLIC_ENVIRONMENT = 'production';
      process.env.AMPLIFY_ENVIRONMENT = 'production';
      
      const validation = await notificationService.validateEnvironment();
      
      expect(validation.environment).toBe('production');
    });

    test('should default to development for safety when environment is unclear', async () => {
      // No environment variables set
      
      const validation = await notificationService.validateEnvironment();
      
      expect(validation.environment).toBe('development');
    });
  });

  describe('Development Environment Safety', () => {
    beforeEach(() => {
      process.env.NODE_ENV = 'development';
      process.env.NEXT_PUBLIC_ENVIRONMENT = 'development';
      process.env.DEBUG_EMAIL = 'info@realtechee.com';
    });

    test('should redirect all notifications to debug email in development', async () => {
      const testRecipients: NotificationRecipient[] = [
        { name: 'Admin 1', email: 'admin1@example.com', role: 'admin' },
        { name: 'AE 1', email: 'ae1@example.com', role: 'ae' },
        { name: 'Manager 1', email: 'manager1@example.com', role: 'manager' }
      ];

      const result = await notificationService.sendNotification({
        templateType: 'contactUs',
        data: {
          formType: 'contact-us',
          submissionId: 'test_123',
          submittedAt: new Date().toISOString(),
          name: 'Test User',
          email: 'test@example.com',
          phone: '555-1234',
          subject: 'Test Subject',
          message: 'Test message'
        },
        recipients: testRecipients,
        channels: 'email',
        priority: 'medium'
      });

      expect(result.recipientValidation?.environmentOverride).toBe(true);
      expect(result.recipientValidation?.validRecipients).toHaveLength(1);
      expect(result.recipientValidation?.validRecipients[0].email).toBe('info@realtechee.com');
    });

    test('should mark E2E test data appropriately', async () => {
      const testData = {
        formType: 'contact-us',
        submissionId: 'e2e_test_123',
        submittedAt: new Date().toISOString(),
        name: 'E2E Test User',
        email: 'e2etest@example.com',
        subject: 'E2E Test',
        message: 'This is an E2E test',
        testData: true,
        leadSource: 'E2E_TEST'
      };

      const result = await notificationService.quickSend('contactUs', testData, {
        testMode: true
      });

      expect(result.success).toBe(true);
      expect(result.recipientValidation?.debugMode).toBe(true);
    });
  });

  describe('Production Environment Role Validation', () => {
    beforeEach(() => {
      process.env.NODE_ENV = 'production';
      process.env.NEXT_PUBLIC_ENVIRONMENT = 'production';
      process.env.AMPLIFY_ENVIRONMENT = 'production';
      process.env.DEBUG_NOTIFICATIONS = 'false';
    });

    test('should query admin and AE users from Cognito in production', async () => {
      const mockUsers = [
        {
          userId: 'user1',
          email: 'admin@realtechee.com',
          role: 'admin',
          status: 'CONFIRMED',
          givenName: 'Admin',
          familyName: 'User',
          groups: ['admin']
        },
        {
          userId: 'user2',
          email: 'ae@realtechee.com',
          role: 'ae',
          status: 'CONFIRMED',
          givenName: 'AE',
          familyName: 'User',
          groups: ['ae']
        },
        {
          userId: 'user3',
          email: 'guest@realtechee.com',
          role: 'guest',
          status: 'CONFIRMED',
          givenName: 'Guest',
          familyName: 'User',
          groups: ['guest']
        }
      ];

      mockAdminService.listUsers.mockResolvedValue({
        users: mockUsers as any,
        nextToken: undefined,
        hasMore: false
      });

      const recipients = await notificationService.getDynamicRecipients('contactUs');

      expect(mockAdminService.listUsers).toHaveBeenCalledWith(100);
      expect(recipients).toHaveLength(2); // Only admin and AE users
      expect(recipients.find(r => r.email === 'guest@realtechee.com')).toBeUndefined();
    });

    test('should filter inactive users', async () => {
      const mockUsers = [
        {
          userId: 'user1',
          email: 'active@realtechee.com',
          role: 'admin',
          status: 'CONFIRMED',
          groups: ['admin']
        },
        {
          userId: 'user2',
          email: 'inactive@realtechee.com',
          role: 'admin',
          status: 'UNCONFIRMED',
          groups: ['admin']
        }
      ];

      mockAdminService.listUsers.mockResolvedValue({
        users: mockUsers as any,
        nextToken: undefined,
        hasMore: false
      });

      const recipients = await notificationService.getDynamicRecipients('contactUs');

      expect(recipients).toHaveLength(1);
      expect(recipients[0].email).toBe('active@realtechee.com');
    });

    test('should fallback to default recipients if Cognito query fails', async () => {
      mockAdminService.listUsers.mockRejectedValue(new Error('Cognito access denied'));

      const recipients = await notificationService.getDynamicRecipients('contactUs');

      // Should fallback to default recipients
      expect(recipients.length).toBeGreaterThan(0);
      expect(recipients[0].email).toBe('info@realtechee.com');
    });
  });

  describe('Priority-Based Filtering', () => {
    const testRecipients: NotificationRecipient[] = [
      { name: 'Super Admin', email: 'super@test.com', role: 'admin' },
      { name: 'AE User', email: 'ae@test.com', role: 'ae' },
      { name: 'Manager', email: 'manager@test.com', role: 'manager' },
      { name: 'Support', email: 'support@test.com', role: 'support' }
    ];

    test('high priority should notify all recipients', async () => {
      process.env.NODE_ENV = 'production';
      process.env.NEXT_PUBLIC_ENVIRONMENT = 'production';
      process.env.AMPLIFY_ENVIRONMENT = 'production';
      
      mockAdminService.listUsers.mockResolvedValue({
        users: [],
        nextToken: undefined,
        hasMore: false
      });

      const result = await notificationService.sendNotification({
        templateType: 'contactUs',
        data: {
          formType: 'contact-us',
          submissionId: 'test_high',
          submittedAt: new Date().toISOString(),
          name: 'High Priority Test',
          email: 'test@example.com',
          subject: 'High Priority',
          message: 'High priority message'
        },
        recipients: testRecipients,
        channels: 'email',
        priority: 'high'
      });

      // Should include all recipients for high priority
      expect(result.success).toBe(true);
    });

    test('medium priority should notify admins and AEs only', async () => {
      process.env.NODE_ENV = 'production';
      process.env.NEXT_PUBLIC_ENVIRONMENT = 'production';
      process.env.AMPLIFY_ENVIRONMENT = 'production';
      
      mockAdminService.listUsers.mockResolvedValue({
        users: [],
        nextToken: undefined,
        hasMore: false
      });

      const result = await notificationService.sendNotification({
        templateType: 'getQualified',
        data: {
          formType: 'get-qualified',
          submissionId: 'test_medium',
          submittedAt: new Date().toISOString(),
          name: 'Medium Priority Test',
          email: 'test@example.com',
          phone: '555-1234'
        },
        recipients: testRecipients,
        channels: 'email',
        priority: 'medium'
      });

      expect(result.success).toBe(true);
      // Would check filtered recipients in actual implementation
    });

    test('low priority should notify admins only', async () => {
      process.env.NODE_ENV = 'production';
      process.env.NEXT_PUBLIC_ENVIRONMENT = 'production';
      process.env.AMPLIFY_ENVIRONMENT = 'production';
      
      mockAdminService.listUsers.mockResolvedValue({
        users: [],
        nextToken: undefined,
        hasMore: false
      });

      const result = await notificationService.sendNotification({
        templateType: 'affiliate',
        data: {
          formType: 'affiliate',
          submissionId: 'test_low',
          submittedAt: new Date().toISOString(),
          companyName: 'Low Priority Company',
          contactName: 'Test Contact',
          email: 'test@example.com',
          phone: '555-1234',
          serviceType: 'Testing'
        },
        recipients: testRecipients,
        channels: 'email',
        priority: 'low'
      });

      expect(result.success).toBe(true);
      // Would check that only admins are notified
    });
  });

  describe('Form Integration Tests', () => {
    beforeEach(() => {
      process.env.NODE_ENV = 'development';
      process.env.NEXT_PUBLIC_ENVIRONMENT = 'development';
      process.env.DEBUG_EMAIL = 'info@realtechee.com';
    });

    test('should integrate Contact Us form properly', async () => {
      const contactData = {
        formType: 'contactUs' as const,
        submissionId: 'contact_123',
        submittedAt: new Date().toISOString(),
        name: 'John Doe',
        email: 'john@example.com',
        phone: '555-1234',
        subject: 'Test Contact',
        message: 'Test message',
        product: 'Kitchen Renovation',
        address: {
          streetAddress: '123 Test St',
          city: 'Test City',
          state: 'TS',
          zip: '12345'
        }
      };

      const result = await formNotificationIntegration.notifyContactUsSubmission(contactData, {
        priority: 'high',
        testMode: true
      });

      expect(result.success).toBe(true);
      expect(result.environment).toBe('development');
      expect(result.debugMode).toBe(true);
    });

    test('should integrate Get Qualified form properly', async () => {
      const qualifiedData = {
        formType: 'getQualified' as const,
        submissionId: 'qualified_123',
        submittedAt: new Date().toISOString(),
        name: 'Jane Agent',
        email: 'jane@realty.com',
        phone: '555-5678',
        licenseNumber: 'RE123456',
        brokerage: 'Test Realty',
        yearsExperience: '5 years'
      };

      const result = await formNotificationIntegration.notifyGetQualifiedSubmission(qualifiedData, {
        priority: 'medium',
        testMode: true
      });

      expect(result.success).toBe(true);
      expect(result.environment).toBe('development');
    });

    test('should integrate Affiliate form properly', async () => {
      const affiliateData = {
        formType: 'affiliate' as const,
        submissionId: 'affiliate_123',
        submittedAt: new Date().toISOString(),
        companyName: 'Test Services Inc',
        contactName: 'Bob Contractor',
        email: 'bob@testservices.com',
        phone: '555-9012',
        serviceType: 'General Contracting'
      };

      const result = await formNotificationIntegration.notifyAffiliateSubmission(affiliateData, {
        priority: 'low',
        testMode: true
      });

      expect(result.success).toBe(true);
      expect(result.environment).toBe('development');
    });
  });

  describe('Error Handling', () => {
    test('should handle notification failures gracefully', async () => {
      process.env.NODE_ENV = 'development';
      
      // Mock a failure in the notification service
      jest.spyOn(notificationService, 'sendNotification').mockRejectedValue(
        new Error('Mock notification failure')
      );

      const result = await formNotificationIntegration.notifyContactUsSubmission({
        formType: 'contactUs',
        submissionId: 'error_test',
        submittedAt: new Date().toISOString(),
        name: 'Error Test',
        email: 'error@test.com',
        subject: 'Error Test',
        message: 'This should handle errors gracefully'
      });

      expect(result.success).toBe(false);
      expect(result.errors).toBeDefined();
      expect(result.errors?.length).toBeGreaterThan(0);
    });

    test('should validate system readiness', async () => {
      const validation = await formNotificationIntegration.validateSystem();

      expect(validation).toHaveProperty('ready');
      expect(validation).toHaveProperty('environment');
      expect(validation).toHaveProperty('cognitoAccess');
      expect(validation).toHaveProperty('templateAccess');
      expect(validation).toHaveProperty('issues');

      if (!validation.ready) {
        expect(validation.issues.length).toBeGreaterThan(0);
      }
    });
  });

  describe('Security Tests', () => {
    test('should never send to unauthorized recipients in production', async () => {
      process.env.NODE_ENV = 'production';
      process.env.NEXT_PUBLIC_ENVIRONMENT = 'production';
      process.env.AMPLIFY_ENVIRONMENT = 'production';
      process.env.DEBUG_NOTIFICATIONS = 'false';

      const unauthorizedRecipients: NotificationRecipient[] = [
        { name: 'Hacker', email: 'hacker@malicious.com', role: 'admin' },
        { name: 'Guest', email: 'guest@somewhere.com', role: 'support' }
      ];

      mockAdminService.listUsers.mockResolvedValue({
        users: [
          {
            userId: 'legit_user',
            email: 'admin@realtechee.com',
            role: 'admin',
            status: 'CONFIRMED',
            groups: ['admin']
          }
        ] as any,
        nextToken: undefined,
        hasMore: false
      });

      const result = await notificationService.sendNotification({
        templateType: 'contactUs',
        data: {
          formType: 'contact-us',
          submissionId: 'security_test',
          submittedAt: new Date().toISOString(),
          name: 'Security Test',
          email: 'security@test.com',
          subject: 'Security Test',
          message: 'This should only go to authorized recipients'
        },
        recipients: unauthorizedRecipients,
        channels: 'email',
        priority: 'high'
      });

      // In production, should use Cognito users, not provided recipients
      expect(result.recipientValidation?.environmentOverride).toBe(false);
      expect(result.success).toBe(true);
    });

    test('should never leak sensitive environment variables', async () => {
      process.env.SECRET_API_KEY = 'very_secret_key';
      process.env.DATABASE_PASSWORD = 'super_secret_password';

      const validation = await notificationService.validateEnvironment();

      // Ensure no sensitive data is exposed in logs or responses
      expect(JSON.stringify(validation)).not.toContain('very_secret_key');
      expect(JSON.stringify(validation)).not.toContain('super_secret_password');
    });
  });
});

// Integration test setup for E2E testing
export const testNotificationSetup = {
  async setupTestEnvironment() {
    process.env.NODE_ENV = 'development';
    process.env.NEXT_PUBLIC_ENVIRONMENT = 'development';
    process.env.DEBUG_NOTIFICATIONS = 'true';
    process.env.DEBUG_EMAIL = 'info@realtechee.com';
    
    return {
      environment: 'development',
      debugMode: true,
      testRecipient: 'info@realtechee.com'
    };
  },

  async cleanupTestData() {
    // Clean up any test notifications from the system
    // This would connect to the actual notification queue/database
    console.log('Cleaning up test notification data...');
  },

  validateNotificationSent(submissionId: string) {
    // This would check if a notification was actually sent
    // for the given submission ID in development mode
    return {
      sent: true,
      recipient: 'info@realtechee.com',
      submissionId
    };
  }
};